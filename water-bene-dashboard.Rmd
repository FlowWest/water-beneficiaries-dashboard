---
title: "Water Beneficiaries Dashboard"
output: 
  flexdashboard::flex_dashboard:
   theme: readable
   font_family: "Roboto"
   google_fonts: true
runtime: shiny
---

```{r setup, include=FALSE}
library(flexdashboard)
library(leaflet)
library(tidyverse)
library(sf)
library(DT)
```

```{r}
# read in processed data
nf_boundaries <- readRDS(here::here("data", "nf_boundaries.RDS"))
watersheds <- readRDS(here::here("data", "watersheds.RDS"))
hydropower <- readRDS(here::here("data", "hydropower.RDS")) #TODO: placeholder

# all_datasets <- readRDS(here::here("data", "all_datasets.RDS"))
all_datasets <- readRDS(here::here("data", "all_datasets_results.RDS"))
```

```{r}
#TODO - check this createria since not sure it is working the way we think
filter_by_metric <- function(data, column, metric) {
  if (metric == "None") {
    return(data)
  } else if (metric == "Top 10%") {
    return(data |>  slice_max(order_by = {{ column }}, prop = 0.10))
  } else if (metric == "Top 25%") {
    return(data |>  slice_max(order_by = {{ column }}, prop = 0.25))
  } else {
    warning("Unrecognized metric. Returning all data.")
    return(data)
  }
  
}
```

Inputs {.sidebar}
-----------------------------------------------------------------------
```{r}

radioButtons(
  inputId = "select_huc_or_nf",
  label = tags$strong("filter by watershed or national forest?"),
  choices = c("Watershed (HUC6)", "National Forest"),
  selected = "National Forest"
)

conditionalPanel(
  condition = "input.select_huc_or_nf == 'Watershed (HUC6)'",
  selectInput(
    inputId = 'select_huc',
    label = tags$strong('Select watershed to identify connected benficiaries'),
    choices = c(unique(all_datasets$watershed_name)),
    selected = "Upper Sacramento" # TODO: placeholder
  )
)

conditionalPanel(
  condition = "input.select_huc_or_nf == 'National Forest'",
  selectInput(
    inputId = 'select_nf',
    label = tags$strong('Select National Forest to identify connected benficiaries'),
    choices = c(unique(all_datasets$national_forest_connection)),
    # choices = c("Eldorado National Forest", "Lassen National Forest", "Mendocino National Forest", "Plumas National Forest", 
    #             "Shasta-Trinity National Forest", "Tahoe National Forest", "Trinity National Forest", "Klamath National Forest",
    #             "Modoc National Forest", "Six Rivers National Forest"),
    selected = "Klamath National Forest"
  )
)

selectInput(
  inputId = "select_bene",
  label = tags$strong("Select type of beneficiary"),
  choices = c("Water right owner" = "water_right",
              "CVP contractor" = "cvp",
              "SWP contractor" = "swp",
              "Public water system" = "pws",
              "Hydropower facility" = "hydropower",
              "Agricultural landowner" = "ag",
              "Business owner" = "business"),
  selected = "hydropower"
)

radioButtons(
  inputId = "select_metric",
  label = tags$strong("Select a metric to filter beneficiaries"),
  choices = c("None", "Top 10%", "Top 25%")
)

checkboxGroupInput(
  inputId = "show_layers",
  label = tags$strong("Toggle base layers"),
  choices = c("Watersheds", "National Forests"),
  selected = c()  
)

```

Row {.tabset}
-----------------------------------------------------------------------

### Map

```{r}
# keeping code in case we want to add the nf and huc boundaries
# boundary <- reactive({
#   if(input$select_huc_or_nf == "National Forest") {
#     print("national forest")
#     return(nf_boundaries |> filter(name == input$select_nf))
#   } else {
#     print("huc")
#     return(watersheds |> filter(name == input$select_huc))
#   }
# })

```

```{r}
output$map <- renderLeaflet({
  leaflet() |> 
    addTiles() |> 
    setView(lng = -122.5, lat = 39, zoom = 7)
})
```

```{r}
#TODO check reactives since they dissapear when tabs are switched back and forth
filtered_dataset <- reactive({
  req(input$select_bene, input$select_huc_or_nf)
  
  bene_type <- case_when(
    input$select_bene == "hydropower" ~ "hydropower facility",
    input$select_bene == "cvp" ~ "cvp contractor",
    input$select_bene == "swp" ~ "swp contractor",
    TRUE ~ NA_character_)
  
  data <- all_datasets |> filter(beneficiary_type == bene_type)

  if (input$select_huc_or_nf == "National Forest" && !is.null(input$select_nf)) {
    data <- data |> filter(national_forest_connection == input$select_nf)
    }
  if (input$select_huc_or_nf == "Watershed (HUC6)" && !is.null(input$select_huc)) {
    data <- data |> filter(watershed_name == input$select_huc)
    }
  return(data)
  })

```

```{r}
observe({ 
  req(input$select_bene, input$select_metric)
  
  tmp_data <- filtered_dataset() |> 
    filter_by_metric(quantity_metric, input$select_metric) |> 
    st_transform(4326)
  
  # popup for all beneficiary types - consider adding more fields?
  popup_content <- ~paste("<strong>Entity Name:</strong>", entity_name, "<br>", "<strong>Address:</strong>", entity_address,
                          "<br>", "<strong>Quantity:</strong>", quantity_metric, quantity_unit)
  #TODO consider just doing points, maybe colored by gradient (max water contract?) however some beneficiaries are MULTI-polygons
  # split polygons and points for plotting purposes
  is_polygon <- st_geometry_type(tmp_data) %in% c("POLYGON", "MULTIPOLYGON") 
  polygons <- tmp_data[is_polygon, ]
  points <- tmp_data[!is_polygon, ]
  
  map_proxy <- leafletProxy("map") |> 
    clearMarkers() |> 
    clearShapes()
  
  if (nrow(polygons) > 0) {
    map_proxy <- map_proxy |>
      addPolygons(data = polygons,
                  weight = 1,
                  color = "brown",
                  fillOpacity = 0.2,
                  popup = popup_content)
    }
  if (nrow(points) > 0) {
    map_proxy <- map_proxy |>
      addCircleMarkers(data = points,
                       lng = ~longitude, 
                       lat = ~latitude,
                       opacity = 1, 
                       fillOpacity = 0.8, 
                       radius = 2,
                       popup = popup_content)
    }
  })

observe({
  proxy <- leafletProxy("map") |>
    clearGroup("Watersheds") |>
    clearGroup("National Forests")
  
  if ("Watersheds" %in% input$show_layers) {
    proxy <- proxy |> addPolygons(data = watersheds,
                                  group = "Watersheds",
                                  color = "blue",
                                  fillOpacity = 0.2,
                                  weight = 1,
                                  popup = ~name)
    }
  if ("National Forests" %in% input$show_layers) {
    proxy <- proxy |> addPolygons(data = nf_boundaries,
                                  group = "National Forests",
                                  color = "forestgreen",
                                  fillOpacity = 0.2,
                                  weight = 1,
                                  popup = ~name)
    }
  })

leafletOutput("map", height = "600px")

```

### Catalog 

```{r}
DTOutput("catalog")
```

```{r}
output$catalog <- renderDT({
  req(input$select_bene, input$select_metric)
  
  tmp_data <- filtered_dataset() |>
    filter_by_metric(quantity_metric, input$select_metric) |>
    st_drop_geometry()  
  
  datatable(tmp_data,
            options = list(pageLength = 10,
                           searching = TRUE,
                           ordering = TRUE)
            )
  })

```

### Summary
