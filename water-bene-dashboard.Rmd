---
title: "Water Beneficiaries Dashboard"
output:
  flexdashboard::flex_dashboard:
    theme: readable
    font_family: Roboto
    google_fonts: true
runtime: shiny
resource_files:
- data/watersheds.RDS
- data/all_datasets_results.RDS
- data/nf_boundaries.RDS
- data/planned_restoration.RDS
---

```{r setup, include=FALSE}
library(flexdashboard)
library(leaflet)
library(tidyverse)
library(sf)
library(DT)
library(viridis)
library(plotly)
```

```{r}
colors <- c('#006475FF', '#00A1B7FF', '#55CFD8FF', '#586028FF', '#898928FF', '#616571FF', '#9DA7BFFF')

# read in processed data
nf_boundaries <- readRDS(here::here("data", "nf_boundaries.RDS"))
watersheds <- readRDS(here::here("data", "watersheds.RDS"))

all_datasets <- readRDS(here::here("data", "all_datasets_results.RDS")) 
planned_restoration <- readRDS(here::here("data", "planned_restoration.RDS"))
```

```{r}
filter_by_metric <- function(data, column, metric) {
  if (metric == "None") {
    return(data)
  } else if (metric == "Top 10%") {
    return(data |>  
             group_by(beneficiary_type) |> 
             slice_max(order_by = {{ column }}, prop = 0.10))
  } else if (metric == "Top 25%") {
    return(data |>  
             group_by(beneficiary_type) |> 
             slice_max(order_by = {{ column }}, prop = 0.25))
  } else {
    warning("Unrecognized metric. Returning all data.")
    return(data)
  }
  
}
```

Inputs {.sidebar}
-----------------------------------------------------------------------
```{r}

radioButtons(
  inputId = "select_huc_or_nf",
  label = tags$strong("Filter by watershed or national forest"),
  choices = c("Watershed (HUC6)", "National Forest"),
  selected = "National Forest")

conditionalPanel(
  condition = "input.select_huc_or_nf == 'Watershed (HUC6)'",
  selectInput(
    inputId = 'select_huc',
    label = tags$strong('Select watershed to identify connected benficiaries'),
    choices = c(unique(all_datasets$watershed_name)),
    selected = "Upper Sacramento") 
)

conditionalPanel(
  condition = "input.select_huc_or_nf == 'National Forest'",
  selectInput(
    inputId = 'select_nf',
    label = tags$strong('Select National Forest to identify connected benficiaries'),
    choices = c(unique(na.omit(all_datasets$national_forest_connection))),
    selected = "Klamath National Forest")
)

selectInput(
  inputId = "select_bene",
  label = tags$strong("Select type of beneficiary"),
  choices = c("All" = "all",
              "Water right owner" = "water_right",
              "CVP contractor" = "cvp",
              "SWP contractor" = "swp",
              "Hydropower facility" = "hydropower",
              "Drinking water system" = "dws"),
  selected = "all"
)

radioButtons(
  inputId = "show_restoration",
  label = tags$strong("Show planned restoration"),
  choices = c("Yes", "No"),
  selected = "Yes"
)

radioButtons(
  inputId = "select_metric",
  label = tags$strong("Select a metric to filter beneficiaries"),
  choices = c("Top 10%", "Top 25%", "None"),
  selected = "None"
)

checkboxGroupInput(
  inputId = "show_layers",
  label = tags$strong("Toggle base layers"),
  choices = c("Watersheds", "National Forests"),
  selected = c()  
)

```

Row {.tabset}
-----------------------------------------------------------------------

### Map

```{r}
output$map <- renderLeaflet({
  leaflet() |> 
    addTiles(group = "Default") |> 
    setView(lng = -122.5, lat = 39, zoom = 7)
})
```

```{r}
#TODO check reactives since they dissapear when tabs are switched back and forth
filtered_dataset <- reactive({
  req(input$select_bene, input$select_huc_or_nf)
  
  data <- all_datasets
  
  if (input$select_bene != "all") {
    bene_type <- case_when( 
      input$select_bene == "hydropower" ~ "hydropower facility",
      input$select_bene == "cvp" ~ "cvp contractor",
      input$select_bene == "swp" ~ "swp contractor",
      input$select_bene == "water_right" ~ "water right owner",
      input$select_bene == "dws" ~ "drinking water system",
      TRUE ~ NA_character_
    )
    data <- data |> filter(beneficiary_type == bene_type)
  }
  
  if (input$select_huc_or_nf == "National Forest" && 
      !is.null(input$select_nf) && input$select_nf != "All") {
    data <- data |> filter(national_forest_connection == input$select_nf)
  }
  
  if (input$select_huc_or_nf == "Watershed (HUC6)" && 
      !is.null(input$select_huc) && input$select_huc != "All") {
    data <- data |> filter(watershed_name == input$select_huc)
  }
  
  return(data)
})

filtered_restoration <- reactive({
  req(input$select_huc_or_nf, input$show_restoration)
  
  if(input$show_restoration == "Yes") {
    
    if (input$select_huc_or_nf == "National Forest" && 
        !is.null(input$select_nf) && input$select_nf != "All") {
      data <- planned_restoration |> filter(national_forest_connection == input$select_nf)
    }
    
    if (input$select_huc_or_nf == "Watershed (HUC6)" && 
        !is.null(input$select_huc) && input$select_huc != "All") {
      data <- planned_restoration |> filter(watershed_name == input$select_huc)
    }
  } else {
    data <- planned_restoration |> slice(0)
  }
  
  return(data)
})

```

```{r}
observe({
  req(input$select_bene, input$select_metric, input$show_restoration)
  
  filtered_restoration() |> glimpse()
  
  tmp_data <- filtered_dataset() |>
    filter_by_metric(quantity_metric, input$select_metric) |>
    st_transform(4326)
  
  if (nrow(tmp_data) == 0) {
    showNotification("No beneficiaries found for the selected type and forest/watershed.",
                     type = "warning", duration = 5)
    leafletProxy("map") |> clearMarkers() |> clearShapes()
    return()
  }
  
  
  bene_pal <- colorFactor(
    palette = colors,
    domain = all_datasets$beneficiary_type
  )
  
  # popup for all beneficiary types - consider adding more fields?
  popup_content <- ~paste("<strong>Entity Name:</strong>", entity_name, "<br>", "<strong>Address:</strong>",
                          entity_address, "<br>", "<strong>Quantity:</strong>", quantity_metric, quantity_unit)
  # split polygons and points for plotting purposes
  is_polygon <- st_geometry_type(tmp_data) %in% c("POLYGON", "MULTIPOLYGON")
  polygons_centroid <- tmp_data[is_polygon, ] |> st_centroid()
  points <- tmp_data[!is_polygon, ]
  
  all_points <- rbind(points, polygons_centroid) |> 
    st_cast("POINT") 
  
  coords <- st_coordinates(all_points)
  all_points$longitude <- coords[, 1]
  all_points$latitude <- coords[, 2]
  all_points <- all_points |> filter(!is.na(longitude), !is.na(latitude))
  
  if (nrow(all_points) == 0) {
    showNotification("There are no valid locations for the selected data.", #TODO think about language of message
                     type = "warning", duration = 5)
    leafletProxy("map") |> clearMarkers() |> clearShapes()
    return()
  }
  
  leafletProxy("map") |>
    clearMarkers() |>
    clearShapes() |>
    clearControls() |> 
    addProviderTiles("CartoDB.Positron", group = "Greyscale") |>
    addProviderTiles("Esri.WorldImagery", group = "Imagery") |>
    addCircleMarkers(data = all_points,
                     lng = ~longitude,
                     lat = ~latitude,
                     radius = ~scales::rescale(quantity_metric, to = c(6, 12)),
                     color = ~bene_pal(beneficiary_type),
                     stroke = TRUE,
                     weight = 1,
                     fillOpacity = 0.8,
                     popup = popup_content,
                     group = "bene") |> 
  addLegend("bottomright",
            pal = bene_pal,
            values = all_points$beneficiary_type,
            title = "Beneficiary Type",
            opacity = 1,
            group = "bene") |> 
    addLayersControl(
      baseGroups = c("Default", "Greyscale", "Imagery"),
      options = layersControlOptions(collapsed = FALSE)
    )
})

observe({
  proxy <- leafletProxy("map") 
  
  if (nrow(filtered_restoration()) > 0) {
    proxy <- proxy |>
      addCircleMarkers(
        data        = filtered_restoration(),
        radius      = 6,
        color       = "darkblue",
        stroke      = FALSE,
        fillOpacity = 0.8,
        popup       = ~paste0(
          "<strong>Project Name:</strong> ", project_name, "<br/>",
          "<strong>Timing:</strong> ", timing_plan, "<br/>",
          "<strong>Contact:</strong> ", contact, "<br/>",
          "<strong>National Forest:</strong> ",
          ifelse(is.na(national_forest_connection), "None", national_forest_connection), "<br/>",
          "<strong>Watershed:</strong> ", watershed_name
        ),
        group = "restoration"
      ) |>
      addLegend(
        position = "bottomright",
        colors   = "darkblue",
        labels   = "Planned Restoration",
        group    = "restoration",
        opacity  = 1
      )
  }
})

observe({
  proxy <- leafletProxy("map") |>
    clearGroup("Watersheds") |>
    clearGroup("National Forests")
  
  if ("Watersheds" %in% input$show_layers) {
    proxy <- proxy |> addPolygons(data = watersheds,
                                  group = "Watersheds",
                                  color = "darkblue",
                                  fillOpacity = 0.2,
                                  weight = 1,
                                  popup = ~name)
  }
  if ("National Forests" %in% input$show_layers) {
    proxy <- proxy |> addPolygons(data = nf_boundaries,
                                  group = "National Forests",
                                  color = "forestgreen",
                                  fillOpacity = 0.2,
                                  weight = 1,
                                  popup = ~name)
  }
  
})

leafletOutput("map", height = "600px")

```

### Beneficiaries Catalog 

```{r}
div(downloadButton("download_catalog", "Download Catalog Selection")
)
div(style = "height: 720px; overflow-y: auto;",
    DTOutput("catalog")
)
```

```{r}
output$catalog <- renderDT({
  req(input$select_bene, input$select_metric)
  
  tmp_data <- filtered_dataset() |>
    filter_by_metric(quantity_metric, input$select_metric) |>
    select(-latitude, -longitude) |> 
    st_drop_geometry() |> 
    arrange(desc(quantity_metric)) |> 
    mutate(quantity_metric = scales::comma(quantity_metric, accuracy = 1)) |>
    rename_with(~ tools::toTitleCase(gsub("_", " ", .x)))
  
  datatable(tmp_data,
            options = list(
              pageLength = 10,
              searching = TRUE,
              ordering = TRUE,
              paging = TRUE,
              lengthChange = TRUE)
  )
})

output$download_catalog <- downloadHandler(
  filename = function() {
    paste0("catalog_", Sys.Date(), ".csv")
  },
  content = function(file) {
    tmp_data <- filtered_dataset() |>
      filter_by_metric(quantity_metric, input$select_metric) |>
      st_drop_geometry()
    
    write.csv(tmp_data, file, row.names = FALSE)
  }
)
```

### Planned Restoration Catalog

```{r}
div(downloadButton("download_restoration_catalog", "Download Restoration Selection")
)
div(style = "height: 720px; overflow-y: auto;",
    DTOutput("restoration_catalog")
)
```

```{r}
output$restoration_catalog <- renderDT({

  tmp_data <- filtered_restoration() |>
    st_drop_geometry() |> 
    rename(timing = timing_plan) |> 
    rename_with(~ tools::toTitleCase(gsub("_", " ", .x)))
  
  datatable(tmp_data,
            options = list(
              pageLength = 10,
              searching = TRUE,
              ordering = TRUE,
              paging = TRUE,
              lengthChange = TRUE)
  )
})

output$download_restoration_catalog <- downloadHandler(
  filename = function() {
    paste0("restoration_catalog_", Sys.Date(), ".csv")
  },
  content = function(file) {
    tmp_data <- filtered_restoration() |>
      st_drop_geometry()
    
    write.csv(tmp_data, file, row.names = FALSE)
  }
)
```

### Summary 

```{r}
plotOutput("top_contractors_plot")
```

```{r}
output$top_contractors_plot <- renderPlot({
  req(input$select_bene, input$select_metric)
  
  tmp_data <- filtered_dataset() |>
    filter_by_metric(quantity_metric, input$select_metric) |>
    st_drop_geometry()
  
  if (nrow(tmp_data) == 0) return(NULL)
  
  top_entities <- tmp_data |>
    select(beneficiary_type, quantity_metric, quantity_unit, entity_name) |>
    st_drop_geometry() |>
    group_by(beneficiary_type, entity_name) |>
    summarise(sum_quantity_metric = sum(quantity_metric)) |>
    arrange(desc(sum_quantity_metric)) |>
    slice_head(n = 10)
  
  ggplot(top_entities, aes(x = reorder(entity_name, sum_quantity_metric), y = sum_quantity_metric, fill = beneficiary_type)) +
    geom_col() +
    coord_flip() +
    theme_minimal() +
    scale_fill_manual(values = colors) +
    scale_y_continuous(
      labels = scales::label_number(
        scale_cut = scales::cut_short_scale(),
        accuracy = 1
      )
    ) +    
    labs(title = "Top 10 Contractors by Quantity",
         x = "",
         y = "Quantity Metric") +
    theme(
      legend.position = "none",   
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
      strip.text = element_text(size = 12, face = "bold")  
    ) +
    facet_grid(~beneficiary_type, scales = "free_x")
})
```






